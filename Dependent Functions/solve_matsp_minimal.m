
function [res,result] = solve_matsp_minimal(data, opts)
%SOLVE_MATSP_MINIMAL  Minimal M-ATSP (Variant A semantics) WITHOUT destination connectivity.
% Encodes exactly equations (1)â€“(7) as agreed:
%   (1)  Minimize C_max
%   (2)  Per-destination coverage: each i served once via some (s,t,r)
%   (3)  Define x from y: x_ir = sum_{s,t} y_istr
%   (4)  Define loads: L_r = sum_{i,s,t} c_{sit} y_istr
%   (5)  L_r <= C_max
%   (6)  Source-degree balance: out(s,r) - in(s,r) = a_sr - b_sr
%   (7)  At most one start and one end per salesman: sum_s a_sr <= 1, sum_s b_sr <= 1
%
% DATA fields (required):
%   n   : |D| number of destinations
%   k   : |S| number of sources (depots)
%   m   : |R| number of salesmen
%   Tgo   (k x n) : time source s -> dest i
%   S      (n x 1): service time at dest i
%   Tback (n x k) : time dest i -> source t
%
% OPTS fields (optional):
%   verbose  : 0/1 (default 1)
%   timeLimit: seconds (default [] uses solver default)
%
% Returns:
%   result struct with fields:
%     x_assign (n x m)          : binary x_ir
%     y_star   (n x k x k x m)  : binary y_istr
%     a_start  (k x m), b_end (k x m)
%     L (m x 1), Cmax (scalar)
%     fval, exitflag, output (from intlinprog)
%
% Author: (auto-generated by ChatGPT)

if nargin < 2, opts = struct(); end
if ~isfield(opts,'verbose'), opts.verbose = 1; end
if ~isfield(opts,'timeLimit'), opts.timeLimit = []; end

% Unpack data
n = data.n; k = data.k; m = data.m;
Tgo = data.Tgo; Svc = data.S(:); Tback = data.Tback;

% Basic checks
assert(isequal(size(Tgo), [k,n]), 'Tgo must be k-by-n');
assert(numel(Svc) == n, 'S must be n-by-1');
assert(isequal(size(Tback), [n,k]), 'Tback must be n-by-k');

% Star-trip times c_{sit}
c = zeros(k,n,k);
for s = 1:k
    for i = 1:n
        for t = 1:k
            c(s,i,t) = Tgo(s,i) + Svc(i) + Tback(i,t);
        end
    end
end

% ---------------- Variable indexing ----------------
% Order variables as: [ y  x  a  b  L  C ]
Ny = n*k*k*m;
Nx = n*m;
Na = k*m;
Nb = k*m;
NL = m;
NC = 1;

ofs.y = 0;
ofs.x = ofs.y + Ny;
ofs.a = ofs.x + Nx;
ofs.b = ofs.a + Na;
ofs.L = ofs.b + Nb;
ofs.C = ofs.L + NL;
Nvars = ofs.C + NC;

    function idx = idxY(i,s,t,r)
        % 1-based linear index of y_{istr}
        idx = ofs.y + (t + (s-1)*k + (i-1)*k*k + (r-1)*n*k*k);
    end
    function idx = idxX(i,r), idx = ofs.x + ((r-1)*n + i); end
    function idx = idxA(s,r), idx = ofs.a + ((r-1)*k + s); end
    function idx = idxB(s,r), idx = ofs.b + ((r-1)*k + s); end
    function idx = idxL(r),   idx = ofs.L + r; end
    function idx = idxC(),    idx = ofs.C + 1; end

% Bounds and integrality
lb = zeros(Nvars,1);
ub = inf(Nvars,1);
vtype = repmat('C', Nvars, 1); % 'B' for binaries

% y, x, a, b are binary; L, C are continuous
for r = 1:m
    for i = 1:n
        ub(idxX(i,r)) = 1; vtype(idxX(i,r)) = 'B';
        for s = 1:k
            for t = 1:k
                ub(idxY(i,s,t,r)) = 1; vtype(idxY(i,s,t,r)) = 'B';
            end
        end
    end
    for s = 1:k
        ub(idxA(s,r)) = 1; vtype(idxA(s,r)) = 'B';
        ub(idxB(s,r)) = 1; vtype(idxB(s,r)) = 'B';
    end
    ub(idxL(r)) = inf; % nonnegative by lb
end
ub(idxC()) = inf;

intcon = find(vtype=='B');

% ---------------- Objective (1): minimize Cmax ----------------
f = zeros(Nvars,1);
f(idxC()) = 1;

% ---------------- Constraint assembly ----------------
Ai = []; Aj = []; Av = []; bi = [];   % inequalities A*x <= b
Ei = []; Ej = []; Ev = []; be = [];   % equalities  Aeq*x = beq

% (2) Coverage: for each destination i, sum_{r,s,t} y_{istr} = 1
for i = 1:n
    cols = [];
    for r = 1:m
        for s = 1:k
            for t = 1:k
                cols(end+1) = idxY(i,s,t,r); %#ok<AGROW>
            end
        end
    end
    Ei = [Ei; repmat(numel(be)+1, numel(cols), 1)];
    Ej = [Ej; cols(:)];
    Ev = [Ev; ones(numel(cols),1)];
    be = [be; 1];
end

% (3) x_{ir} = sum_{s,t} y_{istr}
for r = 1:m
    for i = 1:n
        cols = idxX(i,r);
        vals = 1;
        for s = 1:k
            for t = 1:k
                cols(end+1) = idxY(i,s,t,r); %#ok<AGROW>
                vals(end+1) = -1; %#ok<AGROW>
            end
        end
        Ei = [Ei; repmat(numel(be)+1, numel(cols), 1)];
        Ej = [Ej; cols(:)];
        Ev = [Ev; vals(:)];
        be = [be; 0];
    end
end

% (4) L_r = sum_{i,s,t} c_{sit} y_{istr}
for r = 1:m
    cols = idxL(r);
    vals = 1;
    for i = 1:n
        for s = 1:k
            for t = 1:k
                cols(end+1) = idxY(i,s,t,r); %#ok<AGROW>
                vals(end+1) = -c(s,i,t); %#ok<AGROW>
            end
        end
    end
    Ei = [Ei; repmat(numel(be)+1, numel(cols), 1)];
    Ej = [Ej; cols(:)];
    Ev = [Ev; vals(:)];
    be = [be; 0];
end

% (5) L_r <= Cmax  ->  L_r - Cmax <= 0
for r = 1:m
    Ai = [Ai; numel(bi)+1; numel(bi)+1];
    Aj = [Aj; idxL(r); idxC()];
    Av = [Av; 1; -1];
    bi = [bi; 0];
end

% (6) Source-degree balance: (out - in) = a - b
for r = 1:m
    for s = 1:k
        cols = []; vals = [];
        % out-degree from source s
        for i = 1:n
            for t = 1:k
                cols(end+1) = idxY(i,s,t,r); %#ok<AGROW>
                vals(end+1) = 1; %#ok<AGROW>
            end
        end
        % in-degree to source s
        for i = 1:n
            for t = 1:k
                cols(end+1) = idxY(i,t,s,r); %#ok<AGROW>
                vals(end+1) = -1; %#ok<AGROW>
            end
        end
        % a_sr - b_sr on RHS -> move to LHS: -a_sr + b_sr
        cols(end+1) = idxA(s,r); vals(end+1) = -1;
        cols(end+1) = idxB(s,r); vals(end+1) = +1;
        % equality to 0
        Ei = [Ei; repmat(numel(be)+1, numel(cols), 1)];
        Ej = [Ej; cols(:)];
        Ev = [Ev; vals(:)];
        be = [be; 0];
    end
end

% (7) At most one start and one end per salesman
for r = 1:m
    % sum_s a_sr <= 1
    cols = arrayfun(@(s) idxA(s,r), 1:k);
    Ai = [Ai; repmat(numel(bi)+1, numel(cols), 1)];
    Aj = [Aj; cols(:)];
    Av = [Av; ones(numel(cols),1)];
    bi = [bi; 1];
    % sum_s b_sr <= 1
    cols = arrayfun(@(s) idxB(s,r), 1:k);
    Ai = [Ai; repmat(numel(bi)+1, numel(cols), 1)];
    Aj = [Aj; cols(:)];
    Av = [Av; ones(numel(cols),1)];
    bi = [bi; 1];
end

% Build sparse matrices
A   = sparse(Ai, Aj, Av, numel(bi), Nvars);
Aeq = sparse(Ei, Ej, Ev, numel(be), Nvars);
b   = bi(:);
beq = be(:);

% Solve with intlinprog
if opts.verbose >= 1
    fprintf('[intlinprog] Minimal model: Nvars=%d (bin=%d), A=%d, Aeq=%d\n', ...
        Nvars, numel(intcon), size(A,1), size(Aeq,1));
end
options = optimoptions('intlinprog', 'Display', ternary(opts.verbose>=1,'iter','off'));
if ~isempty(opts.timeLimit), options.MaxTime = opts.timeLimit; end

[xsol,fval,exitflag,output] = intlinprog(f, intcon, A, b, Aeq, beq, lb, ub, options); %#ok<ASGLU>

% Unpack solution
x_assign = zeros(n,m);
y_star   = zeros(n,k,k,m);
a_start  = zeros(k,m);
b_end    = zeros(k,m);
L        = zeros(m,1);
for r = 1:m
    for i = 1:n
        x_assign(i,r) = xsol(idxX(i,r));
        for s = 1:k
            for t = 1:k
                y_star(i,s,t,r) = xsol(idxY(i,s,t,r));
            end
        end
    end
    for s = 1:k
        a_start(s,r) = xsol(idxA(s,r));
        b_end(s,r)   = xsol(idxB(s,r));
    end
    L(r) = xsol(idxL(r));
end
Cmax = xsol(idxC());

result = struct();
result.x_assign = x_assign;
result.y_star   = y_star;
result.a_start  = a_start;
result.b_end    = b_end;
result.L        = L;
result.Cmax     = Cmax;
result.fval     = fval;
result.exitflag = exitflag;
result.output   = output;
res = summarize_routes(result, data);
if opts.verbose >= 1
    fprintf('Cmax = %.6g | exitflag=%d\n', Cmax, exitflag);
end

end

function y = ternary(cond,a,b)
if cond, y = a; else, y = b; end
end


function res = summarize_routes(res, data)
%SUMMARIZE_ROUTES Build human-friendly route info from MILP solution.
%   res = summarize_routes(res, data)
%   Fills these fields for each salesman r (1..m):
%     res.routeCost{r}   : 1 x q  cost of each sub-route (source->city->source)
%     res.startSource(r) : scalar source ID before the 1st city
%     res.bridgeSrc{r}   : 1 x (q-1) source IDs before trips 2..q (i.e., the end source after trips 1..q-1)
%     res.endSource(r)   : scalar source ID after the last city
%     res.ordersD{r}     : 1 x q  city IDs in timeline order
%
% INPUTS:
%   res  : struct from solve_matsp_minimal / solve_matsp_variantA:
%          expects fields y_star (n x k x k x m), a_start (k x m), b_end (k x m)
%   data : struct with time components to compute c_{sit}:
%          Tgo (k x n), S (n x 1), Tback (n x k)
%
% NOTES:
%   - If the chosen star-trips for a salesman form multiple disconnected source-components
%     (possible if you solved the minimal model without extra source connectivity),
%     this function produces a concatenation of per-component trails. The "bridgeSrc"
%     entries will reveal any discontinuities because t(prev) may differ from s(next).
%
% Author: (auto-generated by ChatGPT)

tol = 1e-6;

% Sizes and costs
[n,k,~,m] = size(res.y_star);
Tgo = data.Tgo; Svc = data.S(:); Tback = data.Tback;
c = zeros(k,n,k);
for s = 1:k
    for i = 1:n
        for t = 1:k
            c(s,i,t) = Tgo(s,i) + Svc(i) + Tback(i,t);
        end
    end
end

% Preallocate outputs
res.routeCost  = nan(1,m);
res.ordersD    = cell(1,m);
res.bridgeSrc  = cell(1,m);
res.startSource = nan(1,m);
res.endSource   = nan(1,m);
res.warnings    = cell(1,m);

for r = 1:m
    % -------- collect trips selected for salesman r --------
    trips = []; % struct array with fields: i,s,t,c
    degOut = zeros(1,k);
    degIn  = zeros(1,k);
    for i = 1:n
        for s = 1:k
            for t = 1:k
                if res.y_star(i,s,t,r) > 1 - tol   % tolerate numerics
                    e.i = i; e.s = s; e.t = t; e.c = c(s,i,t);
                    trips = [trips, e]; %#ok<AGROW>
                    degOut(s) = degOut(s) + 1;
                    degIn(t)  = degIn(t) + 1;
                end
            end
        end
    end
    q = numel(trips);
    if q == 0
        res.routeCost(r) = NaN;
        res.ordersD{r}   = [];
        res.bridgeSrc{r} = [];
        % Use a_start / b_end if any
        [~,as] = max(res.a_start(:,r));
        [~,be] = max(res.b_end(:,r));
        if max(res.a_start(:,r))<tol, as = NaN; end
        if max(res.b_end(:,r))<tol, be = NaN; end
        res.startSource(r) = as;
        res.endSource(r)   = be;
        res.warnings{r} = 'No trips for this salesman.';
        continue
    end

    % -------- pick starting source --------
    % Prefer explicit a_start; else use imbalance +1; else any node with out>0
    as_idx = find(res.a_start(:,r) > 1 - tol);
    if ~isempty(as_idx)
        s0 = as_idx(1);
    else
        imb = degOut - degIn;
        cand = find(imb > 0);
        if ~isempty(cand), s0 = cand(1);
        else
            cand = find(degOut > 0);
            s0 = cand(1);
        end
    end
    res.startSource(r) = s0;

    % -------- build adjacency lists (per source) --------
    adj = cell(1,k);
    for eidx = 1:q
        s = trips(eidx).s;
        adj{s} = [adj{s}, eidx]; %#ok<AGROW>
    end
    % sort outgoing edges by destination id, then by end source (deterministic)
    for s = 1:k
        if ~isempty(adj{s})
            [~,ord] = sortrows([[trips(adj{s}).i].' [trips(adj{s}).t].', [ ]]);
            adj{s} = adj{s}(ord);
        end
    end
    used = false(1,q);

    % -------- Hierholzer-style trail per component, concatenated --------
    fullTrail = []; % list of edge indices in visit order
    segments = {};  % to record per-component edges for diagnostics

    while any(~used)
        % choose component start: use s0 for first, otherwise any node with outgoing unused
        if isempty(fullTrail)
            startS = s0;
        else
            % find a source with remaining outgoing unused edge
            startS = find_next_source_with_unused(adj, used, trips, k);
            if isempty(startS)
                break; % should not happen
            end
        end
        segEdges = euler_from(startS, adj, trips, used);
        used(segEdges) = true;
        segments{end+1} = segEdges; %#ok<AGROW>
        fullTrail = [fullTrail, segEdges]; %#ok<AGROW>
    end

    % -------- produce outputs --------
    q = numel(fullTrail);
    if q == 0
        res.routeCost(r) = NaN;
        res.ordersD{r}   = [];
        res.bridgeSrc{r} = [];
        res.endSource(r) = NaN;
        res.warnings{r} = 'No usable trail (unexpected).';
        continue
    end
    order_i = zeros(1,q);
    costs   = zeros(1,q);
    s_list  = zeros(1,q);
    t_list  = zeros(1,q);
    for p = 1:q
        e = trips(fullTrail(p));
        order_i(p) = e.i;
        costs(p)   = e.c;
        s_list(p)  = e.s;
        t_list(p)  = e.t;
    end

    % Start/bridge/end sources on the timeline
    res.ordersD{r}    = order_i;
    res.routeCost(r)  = sum(costs);
    res.startSource(r)= s_list(1);
    res.bridgeSrc{r}  = t_list(1:end-1); % sources before trips 2..q (i.e., end sources after 1..q-1)
    res.endSource(r)  = t_list(end);

    % Diagnostic warning if discontinuities exist (teleport needed)
    jumps = sum(s_list(2:end) ~= t_list(1:end-1));
    if jumps > 0
        res.warnings{r} = sprintf('Non-chainable timeline: %d discontinuit%s (disconnected source-components).', ...
                                  jumps, ternary(jumps==1,'y','ies'));
    else
        res.warnings{r} = '';
    end
end

end % summarize_routes

function segEdges = euler_from(startS, adj, trips, used)
% Build an Euler-style trail starting from startS over unused edges.
stack = startS;
edgeStack = [];   % stack of outgoing edge indices chosen but not yet finalized
segEdges = [];    % result trail in forward order (we'll build reversed, then flip)

% We will pop edges from adj{s} as we use them; so work on a local copy
adjLoc = adj;

while ~isempty(stack)
    u = stack(end);
    % find next unused outgoing edge from u
    eidx = next_unused_edge(adjLoc{u}, used);
    if ~isempty(eidx)
        % take edge eidx: u -> v
        used(eidx) = true; %#ok<NASGU> % mark here so we don't re-pick it in this frame
        edgeStack(end+1) = eidx; %#ok<AGROW>
        v = trips(eidx).t;
        stack(end+1) = v; %#ok<AGROW>
        % Remove eidx from u's adjacency
        adjLoc{u} = remove_edge(adjLoc{u}, eidx);
    else
        % backtrack
        stack(end) = [];
        if ~isempty(edgeStack)
            segEdges(end+1) = edgeStack(end); %#ok<AGROW>
            edgeStack(end) = [];
        end
    end
end

% segEdges currently reversed
segEdges = fliplr(segEdges);
end

function idx = next_unused_edge(edgeList, used)
idx = [];
for p = 1:numel(edgeList)
    e = edgeList(p);
    if ~used(e)
        idx = e; return;
    end
end
end

function lst = remove_edge(lst, e)
% remove first occurrence of e from lst
for p = 1:numel(lst)
    if lst(p)==e
        lst(p) = [];
        return
    end
end
end

function s = find_next_source_with_unused(adj, used, trips, k)
s = [];
for u = 1:k
    el = adj{u};
    for p = 1:numel(el)
        if ~used(el(p))
            s = u; return
        end
    end
end
end


